# 리액트를 다루는 기술

## 리액트

### 왜 리액트인가?

규모가 큰 애플리케이션을 순수 JS로만 관리하려면 힘드니까

Angular, Backbone.js, Derby.js, Ember.js, Ext.js, Knockback.js, Sammy.js, PureMVC, Vue.js 등의 프레임워크가 등장



프레임워크는 주로 MVC(Model-View-Controller) 아키텍쳐, MVVM(Model-View-View Model) 아키텍쳐 등을 사용한다

앵귤러는 MVW(Model-View-Whatever) 아키텍쳐

이런 아키텍쳐들의 공통점은 모델과 뷰가 있다는 것이다

**모델**은 애플리케이션에서 사용하는 데이터를 관리하는 영역이고

**뷰**는 사용자에게 보이는 부분이다



사용자의 인풋 => 컨트롤러는 모델 데이터 조회/수정 => 변경사항 뷰에 반영

뷰에 반영하는 과정에서 보통 뷰가 변형된다

페이스북 개발팀이 최대한 성능을 아끼고 편안한 사용자 경험을 제공하면서 구현하고자 개발한 것이 바로 리액트다

> 어떤 데이터가 변할 때마다 기존 뷰를 날려 버리고 새로 렌더링
>
> 이 때 CPU 점유율이 너무 높은 것이나 메모리의 사용, 끊김 현상들을 해결하는 것이 과제



리액트는 다른 프레임워크와 달리 오직 V에만 신경 쓰는 라이브러리다

리액트에서 특정 부분이 어떻게 생길지 정하는 선언체를 **컴포넌트**라고 한다

다른 프레임워크의 템플릿과는 다르다

템플릿은 보통 데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환하는데

이와 달리 컴포넌트는 재사용이 가능한 API로 수많은 기능들을 내장하고 있으며,

컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의한다



렌더링: 사용자 화면에 뷰를 보여 주는 것

리액트 라이브러리의 효율성은 최초 렌더링과 데이터 변경으로 인한 리렌더링에 있다



#### 초기 렌더링

render()

컴포넌트가 어떻게 생겼는지 정의한다

html 형식의 문자열을 반환하지 않고

뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다



컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈 수 있는데,

이 때 render()를 실행하면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링한다

최상위 컴포넌트의 렌더링 작업이 끝나면

1. HTML 마크업을 만들고 
2. 실제 페이지의 DOM 안에 넣는다

## JSX

## 컴포넌트

## 이벤트 핸들링

## ref: DOM에 이름달기

## 컴포넌트 반복

## 컴포넌트의 라이프사이클 메서드

## Hooks

## 컴포넌트 스타일링

## 일정 관리 웹 애플리케이션

## 컴포넌트 성능 최적화

## immer를 사용한 불변성 유지

## 리액트 라우터로 SPA 개발하기

## 외부 API 연동해서 뉴스 뷰어 만들기

## Context API

## 리덕스 라이브러리

## 리덕스를 사용해서 리액트 애플리케이션 상태 관리하기

## 리덕스 미들웨어를 통한 비동기 작업 관리

## 코드 스플리팅

## 서버 사이드 렌더링

## 백엔드 프로그래밍

Node.js의 Koa 프레임워크

## 몽구스를 이용한 MongoDB 연동 실습

## JWT를 통한 회원 인증 시스템 구현하기

## 프런트엔드 프로젝트

### 시작 및 회원 인증 

### 글쓰기 기능

### 포스트 조회 기능

### 수정/삭제 기능

## 그 다음은?