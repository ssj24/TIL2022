## DML

Data Manipulation Language, 데이터 조작어

데이터를 테이블에 입력 / 수정 / 삭제

### INSERT

1. 단일행

   한 번에 한 행만 입력된다

   `INSERT INTO 테이블 [(칼럼1, 칼럼2...)] VALUES (값1, 값2...)'`

   칼럼명과 입력 값이 1:1 매핑이 되어야 한다

   칼럼 순서는 테이블에 정의된 순서와 같을 필요는 없다

   INTO절에 기술하지 않은 칼럼은 기본값인 NULL로이 된다(not null 칼럼은 오류가 남)

   `INSERT INTO 테이블 VALUES (값1, 값2...);` 이렇게 INTO절에 칼럼명이 생략되면 모든 칼럼 값을 기술해야 한다. 널 허용이어도 무조건.(칼럼명을 지정하는 게 더 안정적임)

   NULL이나 ' ' 이렇게 값 입력 가능

   - 현재 사용 중인 ID에 1을 더한 값을 넣으려면?

     ```sql
     INSERT INTO PLAYER(ID, NAME, TEAM_ID)
     VALUES (
       (
         SELECT TO_CHAR(MAX(TO_NUMBER(ID)) + 1)
         FROM PLAYER
     	),
     	'홍길동', 'K06'
     );
     ```

2. 서브 쿼리를 이용한 다중행

   서브 쿼리의 결과를 테이블에 입력하는 것으로

   서브 쿼리의 결과가 다중행이면 한 번에 여러 건을 입력할 수 있다

   INTO절의 칼럼 개수 = 서브 쿼리 SELECT절 칼럼 개수

   ```sql
   INSERT INTO TEAM (T_ID, REGION, TEAM, ORIG_Y, S_ID)
   SELECT REPLACE(T_ID, 'K', 'A') AS T_ID, REGION, 
   	REGION || '올스타' AS TEAM, 2019 AS ORIG_Y, S_ID
   FROM TEAM
   WHERE REGION IN ('성남', '인천');
   ```

   상기 쿼리의 서브 쿼리는 ()안에 있지 않다!

### UPDATE

`UPDATE 테이블 SET 수정할 칼럼 = 수정될 새 값 [, 칼럼 = 값...] [WHERE];`

where절을 사용하면 해당 행만 수정되고, 쓰지 않으면 전체 데이터가 수정된다

`UPDATE PLAYER SET POSITION = 'MF' WHERE POSITION IS NULL;`

SET절에 서브 쿼리를 쓰면 서브 쿼리의 결과로 값을 수정한다(NULL이 나오면 NULL)

```sql
UPDATE STADIUM A
	SET (A.DDD, A.TEL) = (SELECT X.DDD, X.TEL FROM TEAM X
                       	WHERE X.TEAM_ID = A.HOMETEAM_ID)
WHERE EXISTS (SELECT 1 FROM TEAM X
              WHERE X.TEAM_ID = A.HOMETEAM_ID);
```

SET절의 서브 쿼리는 수정될 값을 식별하고

WHERE절의 서브 쿼리는 수정될 행을 식별한다

상기 쿼리는 TEAM 테이블을 두 번 조회해야 해서 비효율적이므로 MERGE를 사용

```sql
MERGE INTO STADIUM T
USING TEAM S ON (T.TEAM_ID = S.HOMETEAM_ID)
WHEN MATCHED THEN
UPDATE SET T.DDD = S.DDD, T.TEL = S.TEL;
```

### DELETE 

 `DELETE [FROM] 테이블 [WHERE];`

WHERE절을 생략하면 테이블 전체 데이터를 삭제한다

- 창단년도가 1980년 이전인 팀에 소속된 선수를 삭제하자

  ```sql
  DELETE PLAYER A
  WHERE EXISTS (SELECT 1 FROM TEAM X
                WHERE X.TEAM_ID = A.TEAM_ID
               		AND X.ORIG_YYYY < 1980);
  ```

- 소속 선수가 10명 이하인 팀에 소속된 선수를 삭제하자

  ```sql
  DELETE PLAYER
  WHERE TEAM_ID IN (SELECT TEAM_ID FROM PLAYER
                		GROUP BY TEAM_ID
               				HAVING COUNT(*) <= 10);
  ```

테이블 전체 데이터 삭제는 `TRUNCATE TABLE;`가 시스템 부하 적다. 
DELETE는 삭제된 데이터를 로그로 저장하기 때문. 
그 대신 TRUNCATE는 ROLLBACK 불가능하다(SQL서버는 롤백 가능)

|       **DROP**       |                         **TRUNCATE**                         |      **DELETE**      |
| :------------------: | :----------------------------------------------------------: | :------------------: |
|         DDL          |                       DDL(DML도 조금?)                       |         DML          |
|      롤백 불가       |                          롤백 불가                           |    커밋 전, 롤백     |
|     auto commit      |                         auto commit                          |    사용자 commit     |
|    디스크 초기화     | 디스크 초기화,<br />최초 테이블 생성시<br />할당된 스토리지는 남긴다 | 디스크 스토리지 유지 |
| 테이블 정의까지 삭제 |       테이블 생성된 초기상태로<br />테이블 스키마 정의       |    데이터만 삭제     |

### MERGE

새로운 행 입력 및 기존 행 수정을 한 번에 수행할 수 있다

```sql
MERGE INTO 타겟 테이블
USING 소스 테이블 ON (조인 조건식)
	WHEN MATCHED THEN
		UPDATE ... SET ...
	WHEN NOT MATCHED THEN
		INSERT [(칼럼1, 칼럼2...)] VALUES (값1, 값2...);
```

USING절에 소스 테이블 대신 서브 쿼리를 사용할 수 있다

최신 버전 오라클 및 SQL서버는 matched와 not matched 둘 중 한 쪽만 사용 가능



## TCL

Transaction Control Language. 트랜잭션 제어

### 트랜잭션

데이터베이스의 논리적 연산단위

밀접히 관련되어 분리될 수 없는 한 개 이상의 DB 조작

한 트랜잭션에는 SQL 문장이 하나 이상 존재

분할할 수 없는 최소의 단위로 **전부 적용하거나 전부 취소**해야 한다

DB 응용 프로그램은 트랜잭션의 집합이라고 할 수 있다

트랜잭션의 대상: DML

- 트랜잭션의 특성

  **원자성**atomicity: 정의된 연산 모두 실행 OR 모두 비실행

  **일관성**consistency: 실행 전 DB가 올바르다면 실행 후 DB도 올바르다

  **고립성**isolation: 실행 중 다른 트랜잭션의 영향을 받지 않는다

  **지속성**durability: 성공적으로 수행되면 갱신된 DB는 영구적으로 저장된다

> 가나가 다라에게 이체를 할 때, 가나에서 인출되어 다라에게 입금이 되기 전에 다른 트랜잭션이 가나의 계좌 변경을 할 수 없다(잠금LOCKING, 원자성을 위해서)
>
> 잠금이 걸린 데이터는 잠금을 수행한 트랜잭션만 해제할 수 있다

- 트랜잭션에 대한 격리성이 낮을 때 발생하는 문제

  Dirty Read:  다른 트랜잭션에 의해 수정되었는데 아직 커밋되지 않은 데이터를 읽음

  Non-Repeatable Read: 같은 쿼리를 두 번 수행하는 하나의 트랜잭션이 있는데, 이 트랜잭션 수행 중에 다른 트랜잭션이 값을 수정/삭제해서 두 쿼리 결과가 다르게 나타나는 경우

  Phantom Read: 같은 쿼리를 두 번 수행하는 하나의 트랜잭션. 첫 번째 쿼리에서 없던 유령 레코드가 두 번째 쿼리 수행 중 나타남

### COMMIT

트랜잭션의 완료

1. COMMIT / ROLLBACK 이전의 데이터 상태
2. COMMIT 이후의 데이터 상태
3. SQL서버의 COMMIT

### ROLLBACK

### SAVEPOINT



## DDL

### CREATE TABLE



## DCL





DB가 DDL과 DML을 처리하는 방식은 다르다. DDL은 명령어 수행과 동시에 데이터 구조가 변경되지만 DML로 변경된 것을 테이블에 영구 저장하려면 COMMIT으로 트랜잭션을 종료해야 한다(SQL서버는 기본적으로 DML에 AUTO COMMIT 적용!)

## PL/SQL

1. Block구조: 각 기능별 모듈화 가능
2. 여러 SQL문을 block으로 묶고 한 번에 서버로 보낼 수 있어 통신량 감소
3. 변수 / 상수 등을 선언해서  SQL 문장간 값 교환
4. IF, LOOP 등 절차형 언어 사용 가능
5. DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용 가능
6. 오라클에 내장되어 있다
7. 응용 프로그램 성능을 향상시킨다
8. procedutr, user defined function, trigger 객체 작성 가능
9. 프로시저 내 다른 프로시저 호출시 호출 프로시저의 트랜잭션과 별도로 자율 트랜잭션 처리 가능
10. 프로시저 내부에 작성된 절차적 코드는 PL/SQL 엔진이
    일반적인 SQL문장은 SQL실행기가 처리한다
11. 동적 SQL/DDL문을 실행할 때 `EXECUTE IMMEDIATE`를 쓰고 사용해야 한다
    `execute immediate 'TRUNCATE TABLE EMP';`

## 기타...





1. 고객명 써야하는데  GROUP BY를 고객 ID로 했다면?
   SELECT에서  MAX / MIN(고객명)하면 된다

2. ```sql
   TOP N WITH TIES [ORDER BY]
   
   = RANK() OVER ([ORDER BY]) AS RN ... WHERE RN <= N
   ```

   

3. 이거 맞음..? GROUPING 인자는 한 개만..! (두 개는 에러)